# dRICH development
Before getting started with dRICH, you need to clone and build all repositories that you intend to modify. If you don't, the dRICH software will run with what is installed in the `eic-shell` environment. To do this, first source the environment variable,
```bash
source environ.sh
```
then clone and build the repositories (with HTTPS if you're not a member of the EICUG)
```bash
git clone git@github.com:eic/epic.git
./build.sh epic

git clone git@github.com:eic/irt.git
./build.sh irt

git clone git@github.com:eic/EDM4eic.git
./build.sh EDM4eic

# NOTE. The build.sh script fails to build EICrecon, so we have to do it by hand.
#       If I ever figure out what's up I'll try to fix it, but I'm not a CMake
#       expert so that's probably not gonna happen soon.
git clone git@github.com:eic/EICrecon.git
cmake -S EICrecon -B EICrecon/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_FIND_DEBUG_MODE=OFF -DEICRECON_VERBOSE_CMAKE=ON -DCMAKE_INSTALL_PREFIX=/home/twig/code/eic/drich-dev/prefix
cmake --build EICrecon/build -j8
cmake --install EICrecon/build

git clone https://eicweb.phy.anl.gov/EIC/benchmarks/reconstruction_benchmarks.git
./build.sh reconstruction_benchmarks
```
To get a good idea of what version of each EIC software we're using, run the `check_branches.sh` script.

After this, we can build the local `drich-dev` by running `make` on the mother directory.

## Geometry
We can look at the dRICH geometry by running
```bash
geometry.sh -d
```
and then opening the output (in `geo/detector_geometry.root`) using [JSROOT](https://root.cern/js/latest/). If you plan to make a lot of changes to the geometry, it might be a good idea to download a local copy of [JSROOT](https://github.com/root-project/jsroot/releases).

We can take a look at the dRICH geometry constants with te `search_comact_params.sh` script
```bash
./search_compact_params.sh -e | grep DRICH
```
In the output, the first column is the name, the second the raw value, and the third the original formula. Values are in the standard DD4hep units, which (as defined [here](https://dd4hep.web.cern.ch/dd4hep/usermanuals/DD4hepManual/DD4hepManualch2.html)) are
```
static constexpr double centimeter       = 1.;
static constexpr double second           = 1.;
static constexpr double kiloelectronvolt = 1;
static constexpr double eplus            = 1.;
static constexpr double kelvin           = 1.;
static constexpr double mole             = 1.;
static constexpr double candela          = 1.;
static constexpr double radian           = 1.;
static constexpr double steradian        = 1.;
```

After changing any geometry constant, it's a good idea to run an overlap check. This is done automatically as a CI job for every commit associated with a pull request, but it can be done locally (very computationally intensive) by running `overlap_check.sh`.

**NOTE.** There's more details into visualization, CI, and geometry [here](https://github.com/eic/drich-dev/blob/main/doc/tutorials/2-geometry-code.md).

## Running simulations
As seen in the [ddsim documentation](ddsim.md), `ddsim` doesn't have Cherenkov physics. Therefore, we need to use `npsim`. In `drich-dev`, there is a wrapper of `npsim` called `simulate.py`, which is on the root directory. Running it without arguments returns a usage guide.

We can run the script either with centrally generated files (see the [ddsim docs](ddsim.md)), files generated by us (see the [hepmc3 docs](hepmc3.md)), or just run standard pre-generated dRICH tests. The latter is the simplest. For example, if we want to aim 10 pions at the center of the aerogel sector, we do
```bash
./simulate.py -t1 -n10
# Test number <-/ \-> Number of events.
```

We can then view the result of the simulation using ROOT on the `out/sim.edm4hep.root` file. The dRICH hits are contained in the `DRICHHits` branch, which has the following structure:
```
DRICHHits
 +- cellID
 +- EDep
 +- time
 +- pathLength
 +- quality
 +- position
 |   +- x
 |   +- y
 |   +- z
 +- momentum
 |   +- x
 |   +- y
 |   +- z
 +- size
```
Out of these, what we probably care the most about is `position.x`, `position.y`, and `EDep`. We can see the hit distribution across events on a colz plot by running
```C++
events->Draw("DRICHHits.position.y:DRICHHits.position.x>>hist(1000,-2000,2000, 1000,-2000,2000)", "DRICHHits.EDep", "COLZ");
```

We can also look at the hits on an event-by-event basis by using the integrated `event_display` tool
```bash
event_display d s out/sim.edm4hep.root n 0 0
```
To what each option means, please see the usage by running the script with no input. By changing `n` to `i`, we can take an interactive look at a particular event
```bash
event_display d s out/sim.edm4hep.root i 6
```

## Running reconstruction
Instead of having separate software for each detector, EIC software is organized in an attempt to maximize modularity. This setup requires two ingredients:
* **Collections**, which are a set of objects such as sensor hits or PID results. These can be usually separated into input collections and output collections.
* **Algorithms**, which are a transformation of a set of collections to another set of collections.

The EICrecon software is responsible for running algorithms on input collections to build output collections. The full reconstruction forms a reconstruction flowchart, which is a Directed Acyclic Graph (DAG) that with the collections produced by DD4hep and ends with the final collections requested by the user. **Only the collections requested by the users will be produced, and only the minimal set of algorithms that produce these collections will be ran.**

For a quick test of our environment, we can run the full stack (simulation > reconstruction > benchmarks).

```bash
./simulate.py -t1 -n50
./recon.rb
```

`recon.rb` is a wrapper for EICrecon, which
* reads the configuration in the `config/` directory,
* generates an `eicrecon` command, converting said configuration into a set of `-Pparameter=value` options,
* runs `eicrecon` with said options.

After running, we can see the reconstructed files at `out/rec.edm4hep.root`.
